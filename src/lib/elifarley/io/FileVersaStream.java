/* FileVersaStream -- Returns a VersaStream from a local file. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.io;import java.io.RandomAccessFile;import java.io.IOException;import java.io.File;//import java.io.FileDescriptor;public class FileVersaStream extends VersaStream {		//private FileDescriptor fd;	private RandomAccessFile raf;	private boolean canWrite = false;		public FileVersaStream(String name, String mode) throws IOException {		raf = new RandomAccessFile(name, mode);		this.canWrite = mode.toLowerCase().indexOf('w') != -1;		/*		boolean rw = mode.equals("rw");		if (!rw && !mode.equals("r"))			throw new IllegalArgumentException("mode must be r or rw");		SecurityManager security = System.getSecurityManager();		if (security != null) {		    security.checkRead(name);		    if (rw) {			security.checkWrite(name);		    }		}		fd = new FileDescriptor();		open(name, rw);		*/	}	    public FileVersaStream(File file, String mode) throws IOException {		this(file.getPath(), mode);    }	public int read() throws IOException {		return raf.read();	}		    public int read(byte b[], int off, int len) throws IOException {		return raf.read(b, off, len);		//return readBytes(b, off, len);	}	    public int read(byte b[]) throws IOException {		return raf.read(b, 0, b.length);		//return readBytes(b, 0, b.length);    }    /*    public int skipBytes(int n) throws IOException {        seek(getFilePointer() + n);        return n;    }	*/	    public void write(byte b[], int off, int len) throws IOException {		raf.write(b, off, len);		//writeBytes(b, off, len);    }    public void write(byte b[]) throws IOException {		raf.write(b, 0, b.length);		//writeBytes(b, 0, b.length);     }    public void write(int i) throws IOException{		//System.out.println("RAF will write " + i + " ("+ Integer.toHexString(i)+") at " + raf.getFilePointer());		raf.write(i);	}        public boolean canRead() {    	return true;    }    public boolean canWrite() {    	    	return canWrite;    }    public boolean canSeekBackwards() {    	return true;    }    public boolean canSeekForward() {    	return true;    }    public boolean canSeekFromEnd() {    	return true;    }    public boolean canSetSize() {    	return false; // can't set size for now    }	public long seek(long offset, short origin) throws IOException {		long newPos;				switch(origin){			case FROM_BEGINNING: newPos = offset; break;			case FROM_CURRENT: newPos = raf.getFilePointer() + offset; break;			case FROM_END: newPos = raf.length() + offset; break;			default: throw new IOException("Invalid origin: " + origin);		}				//if (newPos < 0) newPos = 0;		if (newPos < 0) throw new IOException("Can't position stream at " + newPos);		if (raf.getFilePointer() != newPos) raf.seek(newPos);		return newPos;	}		public long getSize() throws IOException {		return raf.length();	}	public void setSize(long newSize) throws IOException {		//raf.setSize(newSize);		throw new CannotSetSizeException();	}		public long getPosition() throws IOException {		return raf.getFilePointer();	}		public void setPosition(long pos) throws IOException {		if (pos < 0) throw new IOException("Can't position stream at " + pos);		raf.seek(pos);		}    public boolean markSupported() {		return true;    }    //public native void close() throws IOException;    public void close() throws IOException {    	raf.close();    }	/*    public final FileDescriptor getFD() throws IOException {		if (fd != null) return fd;		throw new IOException();    }	*/	    /*    private native void open(String name, boolean writeable) throws IOException;    private native int readBytes(byte b[], int off, int len) throws IOException;    public native int read() throws IOException;    public native void seek(long pos) throws IOException;    public native void write(int b) throws IOException;    private native void writeBytes(byte b[], int off, int len) throws IOException;    public native long length() throws IOException;    public native long getFilePointer() throws IOException;	*/	}