/* GZipVersaStream -- Returns a VersaStream from a stream in GZIP format. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.io; import java.io.*;import java.util.zip.CRC32;import java.util.zip.CheckedInputStream;import java.util.zip.Inflater;public class GZipVersaStream extends VersaStream {    	protected VersaStream vs;	protected InflaterVersaStream ivs;	protected int infBufSize = 4096;	protected boolean verifyCRC = false;    /**     * CRC-32 for uncompressed data.     */    protected CRC32 crc = new CRC32();    /**     * Indicates end of input stream.     */    protected boolean eos;    public GZipVersaStream(VersaStream vs, int infBufSize) throws IOException {				this.compressionFormat = CF_GZIP;		this.infBufSize = infBufSize;		this.vs = vs;		readHeader();		//crc.reset();		ivs.informSize( readUInt( vs.getInputStream( vs.getSize() - 4 ) ) );    	System.out.println("uncompressed size: " + ivs.getSize() );    }    public GZipVersaStream(VersaStream vs) throws IOException {		this(vs, 4096);	}	    public boolean canRead() {    	return true;    }    public boolean canWrite() {    	return false; // for now    }    public boolean canSeekBackwards() {    	return true;    }    public boolean canSeekForward() {    	return true;    }    public boolean canSeekFromEnd() {    	return true;    }    public boolean canSetSize() {    	return false; // not yet    }    public boolean markSupported() {		return true;    }	public long getPosition() throws IOException {		return ivs.getPosition();	}	public void setPosition(long pos) throws IOException {		ivs.setPosition(pos);	}	    public void setSize(long newSize) throws IOException{		ivs.setSize(newSize);    }	public long seek(long offset, short origin) throws IOException {		return ivs.seek(offset, origin);	}    public int read() throws IOException {		byte[] b = new byte[1];		return read(b, 0, 1) == -1 ? -1 : b[0] & 0xff;    }    public int read(byte[] buf, int off, int len) throws IOException {		if (eos) {		    return -1;		}		len = ivs.read(buf, off, len);		if (len == -1) {		    readTrailer();		    eos = true;		} else {		    //crc.update(buf, off, len);		}		return len;    }	public synchronized void write(int b) throws IOException {		throw new IOException("Writing not supported yet");	}	    /**     * Closes the input stream.     * @exception IOException if an I/O error has occurred     */    public void close() throws IOException {		ivs.close();		vs.close();		eos = true;    }    /**     * GZIP header magic number.     */    public final static int GZIP_MAGIC = 0x8b1f;    /*     * File header flags.     */    protected final static int FTEXT	= 1;	// Extra text    protected final static int FHCRC	= 2;	// Header CRC    protected final static int FEXTRA	= 4;	// Extra field    protected final static int FNAME	= 8;	// File name    protected final static int FCOMMENT	= 16;	// File comment    /*     * Reads GZIP member header.     */    private void readHeader() throws IOException {		CheckedInputStream in = new CheckedInputStream(this.vs.getInputStream(0), crc);		crc.reset();		// Check header magic		if (readUShort(in) != GZIP_MAGIC) {		    throw new IOException("Not in GZIP format");		}		// Check compression method		if (readUByte(in) != 8) {		    throw new IOException("Unsupported compression method");		}		// Read flags		int flg = readUByte(in);		// Skip MTIME, XFL, and OS fields		skipBytes(in, 6);		// Skip optional extra field		if ((flg & FEXTRA) == FEXTRA) {		    skipBytes(in, readUShort(in));		}		// Skip optional file name		if ((flg & FNAME) == FNAME) {		    while (readUByte(in) != 0) ;		}		// Skip optional file comment		if ((flg & FCOMMENT) == FCOMMENT) {		    while (readUByte(in) != 0) ;		}		// Check optional header CRC		if ((flg & FHCRC) == FHCRC) {		    int v = (int)crc.getValue() & 0xffff;		    if (readUShort(in) != v) {			throw new IOException("Corrupt GZIP header");		    }		}		this.ivs = new InflaterVersaStream(vs.getInputStream(), new Inflater(true), infBufSize);    }    /*     * Reads GZIP member trailer.     */    private void readTrailer() throws IOException {		InputStream in = this.vs.getInputStream();		int n = ivs.inf.getRemaining();		if (n > 0) {		    in = new SequenceInputStream(				new ByteArrayInputStream(ivs.buf, ivs.len - n, n), in);		}				long fv = readUInt(in);		long v;				if ( verifyCRC && ( fv != (v = crc.getValue() ) ) ) {		    throw new IOException("CRC values don't match");		}				if (readUInt(in) != ivs.inf.getTotalOut() ) {		    throw new IOException("Uncompressed sizes don't match");		}    }    /*     * Reads unsigned integer in Intel byte order.     */    private long readUInt(InputStream in) throws IOException {	long s = readUShort(in);	return ((long)readUShort(in) << 16) | s;    }    /*     * Reads unsigned short in Intel byte order.     */    private int readUShort(InputStream in) throws IOException {	int b = readUByte(in);	return ((int)readUByte(in) << 8) | b;    }    /*     * Reads unsigned byte.     */    private int readUByte(InputStream in) throws IOException {	int b = in.read();	if (b == -1) {	    throw new EOFException();	}	return b;    }    /*     * Skips bytes of input data blocking until all bytes are skipped.     * Does not assume that the input stream is capable of seeking.     */    private void skipBytes(InputStream in, int n) throws IOException {	byte[] buf = new byte[128];	while (n > 0) {	    int len = in.read(buf, 0, n < buf.length ? n : buf.length);	    if (len == -1) {		throw new EOFException();	    }	    n -= len;	}    }    }