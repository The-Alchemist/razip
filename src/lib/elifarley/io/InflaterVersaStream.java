/* InflaterVersaStream -- Returns a VersaStream from an Inflater. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.io;import java.util.zip.Inflater;import java.util.zip.DataFormatException;import java.util.zip.ZipException;import java.io.InputStream;import java.io.IOException;import java.io.EOFException;/** * This class implements a stream filter for uncompressing data in the * "deflate" compression format. It is also used as the basis for other * decompression filters, such as GZIPInputStream. * * @see		Inflater * @version 	1.16, 03/19/98 * @author 	David Connelly */publicclass InflaterVersaStream extends PosVersaStream {        //protected int curPos;    protected boolean sizeIsKnown = false;    protected long size = 0;    protected boolean closed = false;        protected InputStream in;    /**     * Decompressor for this stream.     */    protected Inflater inf;    /**     * Input buffer for decompression.     */    protected byte[] buf;    /**     * Length of input buffer.     */    protected int len;    /**     * Creates a new input stream with the specified decompressor and     * buffer size.     * @param in the input stream     * @param inf the decompressor ("inflater")     * @param size the input buffer size     */    public InflaterVersaStream(InputStream in, Inflater inf, int size) {		this.in = in;		this.inf = inf;		buf = new byte[size];		pos = 0;		//curPos = 0;    }    /**     * Creates a new input stream with the specified decompressor and a     * default buffer size.     * @param in the input stream     * @param inf the decompressor ("inflater")     */    public InflaterVersaStream(InputStream in, Inflater inf) {		this(in, inf, 4096);    }    /**     * Creates a new input stream with a default decompressor and buffer size.     */    public InflaterVersaStream(InputStream in) {		this(in, new Inflater());    }    public Inflater getInflater() {    	return inf;    }        public boolean setVSOffset(long vs_offset) {		boolean result = ((VersaStreamInputStream) in).setVSOffset(vs_offset);		if (result) {			parentStreamChanged();		}		return result;	}    public synchronized void reset() throws IOException {		in.reset();		inf.reset();		pos = 0;		//curPos = 0;    }	public void parentStreamChanged() {		//System.out.println("parentStreamChanged to offset: " + ((VersaStreamInputStream) in).getVSOffset());		inf.reset();		//curPos = 0;		pos = 0;		size = 0;		sizeIsKnown = false;			}		public InputStream getParentInputStream() {		return in;	}		public void setParentInputStream(InputStream in) throws IOException {		this.in = in;			parentStreamChanged();	}    public boolean canRead() {    	return true;    }    public boolean canWrite() {    	return false; // for now    }    public boolean canSeekBackwards() {    	return true;    }    public boolean canSeekForward() {    	return true;    }    public boolean canSeekFromEnd() {    	return true;    }    public boolean canSetSize() {    	return false; // not yet    }    public boolean markSupported() {		return false;    }		public synchronized void mark(int readLimit) {		throw new IllegalArgumentException("Mark not supported");	}			public void close() throws IOException {				if (!closed) {			buf = null;			in.close();			in = null;			inf.end();			closed = true;		}			}		protected void informSize(long size) {		if (size < 0) throw new IllegalArgumentException("Size cannot be " + size);		this.size = size;		sizeIsKnown = true;			}		public void findOutSize() throws IOException {		sizeIsKnown = false;		reset();		int len;		long tempSize = 0;				while (true) {			len = (int)this.skip(65536);			if (len < 1) break;			tempSize += len;		}		informSize(tempSize);	}		public synchronized long getSize() throws IOException {		if (!sizeIsKnown) {			findOutSize();		}		return size;	}	    public void setSize(long newSize) throws IOException{		throw new CannotSetSizeException("Not yet supported");    }		public synchronized void write(int b) throws IOException {		throw new IOException("Writing not supported yet");	}	    /**     * Reads a byte of uncompressed data. This method will block until     * enough input is available for decompression.     * @return the byte read, or -1 if end of compressed input is reached     * @exception IOException if an I/O error has occurred     */    public int read() throws IOException {		byte[] b = new byte[1];		return read(b, 0, 1) == -1 ? -1 : b[0] & 0xff;    }    /**     * Reads uncompressed data into an array of bytes. This method will     * block until some input can be decompressed.     * @param b the buffer into which the data is read     * @param off the start offset of the data     * @param len the maximum number of bytes read     * @return the actual number of bytes read, or -1 if the end of the     *         compressed input is reached or a preset dictionary is needed     * @exception ZipException if a ZIP format error has occurred     * @exception IOException if an I/O error has occurred     */    public synchronized int read(byte[] b, int off, int len) throws IOException {		if (len <= 0) {		    return 0;		}				if (inf.getTotalOut() != pos) {			try {				updatePos();			} catch (IOException ioe) {				ioe.printStackTrace();				return -1;			}					}				return internalRead(b, off, len);		    }		protected void updatePos() throws IOException {				int toSkip = (int) (pos - inf.getTotalOut());				if (toSkip < 0) { // we must seek backwards			//System.out.println("Seeking backwards");			//in.close();			toSkip = (int)pos;			this.reset();		}						//if (toSkip < 0) throw new IOException("toSkip < 0: " + toSkip);									if (toSkip > 0) {			//System.out.println("inf.getTotalOut: " + inf.getTotalOut());			//System.out.println("Skipping: " + toSkip);			int s = (int)this.skip(toSkip);			if (s != toSkip) {				System.out.println("Failed to skip to " + toSkip);				System.out.println("Skipped: " + s);				throw new IOException("Could not skip " + toSkip);			}		}				//System.out.println("inf.getTotalOut: " + inf.getTotalOut());	}    protected int internalRead(byte[] b, int off, int len) throws IOException {		if (len <= 0) {		    return 0;		}		try {		    int n;		    		    while ((n = inf.inflate(b, off, len)) == 0) {				if (inf.finished() || inf.needsDictionary()) {				    return -1;				}				if (inf.needsInput()) {				    fill();				}		    }		    		    /*		    if (n != -1) {			    curPos += n;		    } else {		    	System.out.println(" n == -1 !!!!!");		    }		    */		    		    pos = inf.getTotalOut(); //curPos;		    return n;				} catch (DataFormatException e) {		    String s = e.getMessage();		    throw new ZipException(s != null ? s : "Invalid ZLIB data format");		}    }	    /**     * Skips specified number of bytes of uncompressed data.     * @param n the number of bytes to skip     * @return the actual number of bytes skipped.     * @exception IOException if an I/O error has occurred     */    protected long skip(long n) throws IOException {		byte[] b = new byte[65536];		long total = 0;		long len;		while (total < n) {		    len = n - total;	    		    if ( (len = internalRead(b, 0, len < b.length ? (int)len : b.length)) == -1) {				break;		    }		    total += len;		}		return total;    }    /**     * Fills input buffer with more data to decompress.     * @exception IOException if an I/O error has occurred     */    protected void fill() throws IOException {		len = in.read(buf, 0, buf.length);		if (len == -1) {			System.out.println("total Out: " +  inf.getTotalOut() );			System.out.println("total In: " +  inf.getTotalIn() );			System.out.println("offset: " +  ((VersaStreamInputStream) in).getVSOffset() );			System.out.println("maxLen: " +  ((VersaStreamInputStream) in).getMaxLen() );		    throw new EOFException("Unexpected end of ZLIB input stream");		}		inf.setInput(buf, 0, len);    }    }