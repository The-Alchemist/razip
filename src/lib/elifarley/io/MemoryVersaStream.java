/* MemoryVersaStream -- A VersaStream which stores its data in a byte array. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.io;import java.io.IOException;import java.io.InputStream;import java.io.DataOutput;import java.io.OutputStream;import java.io.Writer;public class MemoryVersaStream extends PosVersaStream {	    protected byte buf[];	protected boolean usesExternalBuffer;    protected int count = 0;    protected int capacityIncrement;		public MemoryVersaStream(byte buf[]) {		this.buf = buf;		this.count = buf.length;		this.usesExternalBuffer = true;	}	public MemoryVersaStream(int initialCapacity, int capacityIncrement) {		this.buf = new byte[initialCapacity];		this.capacityIncrement = capacityIncrement;		this.usesExternalBuffer = false;	}		public MemoryVersaStream(int initialCapacity) {		this(initialCapacity, 0);	}	public MemoryVersaStream() {		this(512);	}    public boolean canRead() {    	return true;    }    public boolean canWrite() {    	return true;    }    public boolean canSeekBackwards() {    	return true;    }    public boolean canSeekForward() {    	return true;    }    public boolean canSeekFromEnd() {    	return true;    }    public boolean canSetSize() {    	return !usesExternalBuffer;    }    public boolean markSupported() {		return true;    }		public void close() throws IOException {		buf = null;	}		public synchronized long getSize() throws IOException {		return count;	}    public final synchronized void setSize(long newSize) throws IOException{				if (usesExternalBuffer)			throw new CannotSetSizeException("Stream uses external buffer");					if (( (int)newSize > count) && ( (int)newSize > buf.length)) {		    ensureCapacityHelper( (int)newSize);		} else {		    for (int i = (int)newSize ; i < count ; i++) {			buf[i] = 0;		    }		}		count = (int)newSize;    }		public int read() throws IOException {		if (pos >= count) return -1;		return  0xff & buf[(int)(pos++)]; // HOW COULD I FORGET TO PUT THE "0xff &" THING!!!!!	}		    public int read(byte b[], int off, int len) throws IOException {		int maxLen = (int) (count - pos);		if (maxLen < 1) return -1;		if (len > maxLen) len = maxLen; 		System.arraycopy(buf, (int)pos, b, off, len);		pos += len;		return len;	}		public synchronized void write(int b) throws IOException {		if (pos >= count) {						ensureCapacityHelper((int)pos + 1);			count = (int)pos + 1 ;		}		buf[(int)(pos++)] = (byte)b;	}    public synchronized void write(byte b[], int off, int len) throws IOException {		int pl = (int)pos + len;		if (pl > count) {			ensureCapacityHelper(pl);			count = pl;		}				System.arraycopy(b, off, buf, (int)pos, len);		pos = pl;	}		public byte[] getBuffer() {		return buf;	}	public synchronized long copyTo(DataOutput dest, long count) throws IOException {		  		  		if (count < 0) {  			if (pos != 0) pos = 0;  			count = this.count - pos;  		} else {			if (count == 0) count = this.count - pos;		}				if (count > 0) {			synchronized (buf) {	    		dest.write( buf, (int)pos, (int)count ); 			}    		return count;		}					return 0;		  	}    public synchronized long copyTo(OutputStream dest, long count) throws IOException {		  		  		if (count < 0) {  			if (pos != 0) pos = 0;  			count = this.count - pos;  		} else {			if (count == 0) count = (int)(this.count - pos);		}				if (count > 0) {			synchronized (buf) {	    		dest.write( buf, (int)pos, (int)count ); 			}    		return count;		}				return 0;			  	}    public synchronized long copyTo(Writer dest, long count) throws IOException {  		if (count < 0) {  			if (pos != 0) pos = 0;  			count = this.count - pos;  		} else {			if (count == 0) count = this.count - pos;		}				if (count > 0) {			synchronized (buf) {	    		dest.write(new String(buf, (int)pos, (int)count ) ); 			}    		return count;		}				return 0;	}    /*    public synchronized long copyTo(String dest, long count) throws IOException {  		if (count < 0) {  			if (pos != 0) pos = 0;  			count = this.count - pos;  		} else {			if (count == 0) count = this.count - pos;		}				if (count > 0) {			synchronized (buf) {	    		dest = new String(buf, pos, (int)count ); 			}    		return count;		}				return 0;	}    public synchronized String toString() {		return new String(((MemoryVersaStream)this).buf, 0, this.count);	}	*/	    public final synchronized void trimToSize() {	int oldCapacity = buf.length;	if (count < oldCapacity) {	    byte oldBuf[] = buf;	    buf = new byte[count];	    System.arraycopy(oldBuf, 0, buf, 0, count);	}    }    public final synchronized void ensureCapacity(int minCapacity) throws IOException {	if (minCapacity > buf.length) {	    ensureCapacityHelper(minCapacity);	}    }    private void ensureCapacityHelper(int minCapacity) throws IOException {		if (usesExternalBuffer)			throw new CannotSetSizeException("Stream uses external buffer");		int oldCapacity = buf.length;		byte oldBuf[] = buf;		int newCapacity = (capacityIncrement > 0) ?		    (oldCapacity + capacityIncrement) : (oldCapacity * 2);		if (newCapacity < minCapacity) {		    newCapacity = minCapacity;		}		buf = new byte[newCapacity];		System.arraycopy(oldBuf, 0, buf, 0, count);    }		}