/* RAZipVersaStream -- provides fast random access to compressed data in RAZip format * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */package elifarley.razip;import elifarley.razip.RAZipHandler;import elifarley.razip.RAZipConstants;import elifarley.io.VersaStreamConstants;import elifarley.io.VersaStream;import elifarley.io.InflaterVersaStream;import elifarley.io.PosVersaStream;import elifarley.io.VersaStreamInputStream;import elifarley.io.CannotSetSizeException;import elifarley.util.VersaObjCache;import java.util.Vector;import java.util.Hashtable;import java.io.IOException;import java.io.EOFException;import java.io.InputStream;import java.io.OutputStream;import java.util.Date;import java.util.zip.Inflater;import java.util.zip.DeflaterOutputStream;import java.util.zip.Deflater;import java.util.zip.CRC32;public class RAZipVersaStream extends PosVersaStream implements RAZipConstants, VersaStreamConstants {    public RAZipHandler RAZ_H;	protected int maxBlockSize = (int) (256 * 1024);    protected CRC32 crc = new CRC32();	protected int CRC;	protected VersaStream vs;	//protected InflaterInputStream iis;	protected DeflaterOutputStream dos;	protected Deflater def;	//protected BlockAndUOff currentBO;	protected BlockAndUOff lastBO;	protected long size;	protected long blockCount;	protected boolean lastBlockReady = false;		protected boolean resForkMode = false;		protected int lastReadBlockIndex = 0;	protected InflaterVersaStream lastInflaterVS = null;	protected int maxHTSize = 16;	protected Hashtable ht = null;	protected static int inflaterBufSize = 16 * 1024; // 70 * 1024 ?    public static final int maxInflaterPoolSize = 0; // should be bigger than zero !!!    // List of available Inflater objects for decompression    protected static VersaObjCache infCache = new VersaObjCache(maxInflaterPoolSize) {	    	    protected Object createNewObj() { return new Inflater(true); }	    	    protected void reset(Object obj) {			if (obj == null) {				System.out.println("Obj is null !!!!");			} else {				System.out.println("will reset Obj " + obj.toString());			}	    		    	try {	    		( (Inflater)obj ).reset();	    	} catch(NullPointerException npe) {	    		npe.printStackTrace();	    	}			System.out.println("Done Obj " + obj.toString());	    		    }	};	protected int deflaterBufSize = 70 * 1024;	public RAZipVersaStream(VersaStream vs) throws IOException {		this.compressionFormat = CF_RAZIP;		//trailerPresent = false;		//cpVector = null;		CRC = 0;		//currentBO = new BlockAndStream(null, 0);		lastBO = new BlockAndUOff(null, -1);		this.vs = vs;				RAZ_H = new RAZipHandler(this);			}	public void setAccessPriority(short pri) {		super.setAccessPriority(pri);				if ( accessPriority == AP_RANDOM ) {			lastInflaterVS = null;			if (ht == null) ht = new Hashtable(maxHTSize);		} else {			ht = null;			if (lastInflaterVS == null) {				try {					lastInflaterVS = getIVS(-1, -1);				} catch (IOException ioe) {					ioe.printStackTrace();					lastInflaterVS = null;				}			}					}			}		public void setResForkMode() {		resForkMode = true;	}	public void setDataForkMode() {		resForkMode = false;	}	public boolean resForkModeIsActive() {		return resForkMode;	}		public boolean dataForkModeIsActive() {		return !resForkMode;	}		//		public int getMaxBlockSize() {		return maxBlockSize;	}		/**	 * Sets the maximum number of uncompressed bytes each block can store	*/	public void setMaxBlockSize(int maxBlockSize) {		this.maxBlockSize = maxBlockSize;	}		protected InflaterVersaStream getIVS(long cPos, long cLen) throws IOException {		return new InflaterVersaStream(vs.getInputStream(cPos, cLen), (Inflater)infCache.getObject(), inflaterBufSize) {			protected boolean isClosed = false;						public void close() throws IOException {				if (!isClosed) {					super.close();					infCache.releaseObject(inf);					isClosed = true;				}			}		};		}	public void breakBlock() throws IOException {		flushLastBlock();			}		public int read() throws IOException {    	byte b[] = new byte[1];		return read(b, 0, 1) == -1 ? -1 : b[0] & 0xff;	}    public int read(byte b[], int off, int len) throws IOException {						if (this.pos >= this.size) {			System.out.println("pos >= size: " + pos );			return -1;		}		BlockInfo cpi = null;				int uOff = 0;		boolean found = false;		int i, leftI, rightI;		leftI = 0;		rightI = RAZ_H.cpVector.size() - 1;		i = lastReadBlockIndex;				do {						cpi = (BlockInfo) RAZ_H.cpVector.elementAt(i);						uOff = (int) ( (this.pos + RAZ_H.cHeaderSize) - cpi.uPos);						// test if this.pos comes before cpi			if (uOff < 0) {				rightI = i - 1;			} else				// test if this.pos comes after cpi				// this.pos > cpi.uPos + cpi.uLen				if (uOff >= cpi.uLen) {					leftI = i + 1;				} else {					//result = new BlockAndUOff(cpi, uOff);					found = true;					lastReadBlockIndex = i;					break;				}			i = (leftI + rightI) >> 1;						} while (leftI <= rightI);						if (found) {			if (accessPriority != AP_RANDOM) {								if (lastInflaterVS.setVSOffset(cpi.cPos)) {					((VersaStreamInputStream)lastInflaterVS.getParentInputStream()).setMaxLen(cpi.cLen);				}								//lastInflaterVS.setPosition(uOff);				len = lastInflaterVS.read(uOff, b, off, len);			} else {				System.out.println("Random access...");				//len = cpi.getBlockVS().read(uOff, b, off, len);				len = getBlockVS(cpi).read(uOff, b, off, len);						}						if (len != -1) {				//currentBO.bs.uOff += len;				pos += len;			} else {				System.out.println("len == -1; pos: " + pos);			}						return len;		} else {			System.out.println("Not found: " + this.pos);			return -1;		}			}		public VersaStream getBlockVS(BlockInfo cpi) throws IOException {				if (accessPriority != AP_RANDOM) {						if (lastInflaterVS.setVSOffset(cpi.cPos)) {				((VersaStreamInputStream)lastInflaterVS.getParentInputStream()).setMaxLen(cpi.cLen);			}						//lastInflaterVS.setPosition(uOff);			return lastInflaterVS;		} else {			InflaterVersaStream bs = (InflaterVersaStream)ht.get(cpi);						if (bs == null) {								if (ht.size() < maxHTSize) {					bs = getIVS(cpi.cPos, cpi.cLen);					//bs.setPosition(uOff);				} else {					// Let's make room for a new bs					// must use an algorithm to remove the most arpopriate bs (oldest one?)					bs = (InflaterVersaStream) ( ht.remove( ht.keys().nextElement() ) );					bs.setVSOffset(cpi.cPos);					//bs.setPosition(uOff);				}								ht.put(cpi, bs);							} else {				//bs.setPosition(uOff);			}			return bs;		}		}	protected BlockInfo getNewBlock(BlockInfo block) {		//System.out.println("getNewBlock; cPos: " + (block.cPos + block.cLen + blockTrailerSize) + "; uPos: " + (block.uPos + block.uLen) );		// int cLen, int uLen, long cPos, long uPos, CRC, ILBIF		return new BlockInfo(0, 0, block.cPos + block.cLen + RAZ_H.blockTrailerSize, block.uPos + block.uLen, 0, false);		}		protected void createFirstWriteBlock() throws IOException {		RAZ_H.decodeFlags();		RAZ_H.blockTrailerSize = MIN_BLOCK_TRAILER_SIZE;		if (RAZ_H.checkBlockIntegrity) {			RAZ_H.blockTrailerSize += RAZ_H.bCRCLen;		}				RAZ_H.trailerSize = (int)RAZ_H.crcLen + MIN_TRAILER_SIZE;				// int cLen, int uLen, long cPos, long uPos		lastBO.block = new BlockInfo(0, 0, RAZ_H.firstBlockPos, 0, 0, false);		RAZ_H.cpVector.addElement(lastBO.block);		createNewDOS();	}		protected void createNewDOS() throws IOException {		lastBO.block.flushed = false;		lastBO.block.uLen = 0;		//System.out.println("Will create new dos at " + lastBO.block.cPos);				def = new Deflater(9, true);		/*		DEFAULT_STRATEGY:		FILTERED: more huffman, less string matching, used with small values, rand distr		HUFFMAN_ONLY:		*/		def.setStrategy(Deflater.DEFAULT_STRATEGY);								dos = new DeflaterOutputStream(vs.getOutputStream(lastBO.block.cPos),		def, deflaterBufSize) {	   	private boolean isClosed = false;	        	        public void write(byte[] b, int off, int len) throws IOException {				super.write(b, off, len);				lastBO.block.uLen += len;				size += len;			}					public void close() throws IOException {				if (!isClosed) {					//defCache.releaseObject(def);					finish();					//this.out.close();					isClosed = true;				}			}					};	}		protected void appendBlock() throws IOException {						RAZ_H.trailerPresent = false;		if (lastBO.block == null) {						if (!RAZ_H.headerStarted) {				RAZ_H.writeHeader();			} else {				createFirstWriteBlock();						}						return;					} else {						if (!lastBO.block.flushed && lastBO.block.uLen > 0) {				flushLastBlock();				}			if (lastBO.block.cLen > 0) {								lastBO.block = getNewBlock(lastBO.block);				RAZ_H.cpVector.addElement(lastBO.block);			}		}				createNewDOS();			}			protected void flushLastBlock() throws IOException {		flushLastBlock(false);	}		protected void flushLastBlockAndFork() throws IOException {		flushLastBlock(true);	}	protected void flushLastBlock(boolean endOfFork) throws IOException {				if (lastBO.block == null || lastBO.block.flushed || lastBO.block.uLen < 1) {			if (dos != null)				throw new IOException("dos != null !!!!!!");						return;		}						dos.finish();		lastBO.block.cLen = (int) (vs.getPosition() - lastBO.block.cPos);		//lastBO.block.uLen		if (endOfFork) {			lastBO.block.isLastBlockInFork = true;			System.out.println("This is the last block of current fork");		}				RAZ_H.writeBlockTrailer(lastBO.block);		dos = null; // will dos close the underlying stream?	}        protected synchronized OutputStream getBlockOutputStream() throws IOException {		//BlockInfo lastBlock = (BlockInfo) cpVector.elementAt(cpVector.size() - 1);						if (lastBO.block == null || lastBO.block.flushed) {			appendBlock();		}				if (this.pos + RAZ_H.cHeaderSize != lastBO.block.uPos + lastBO.block.uLen) {			System.out.println("Error");			System.out.println("pos " + pos);			System.out.println("RAZ_H.cHeaderSize " + RAZ_H.cHeaderSize);			System.out.println("lastBO.uOff " + lastBO.block.uLen);			System.out.println("lastBO.block.cPos " + lastBO.block.cPos);						throw new IOException("Can only write at the end of the stream");		}		// assert(!lastBO.block.flushed)		if (dos == null) throw new IOException("dos should not be null here!");				return dos;			    }        public synchronized void write(byte b[], int off, int len) throws IOException {				int bytesAllowed;		int chunkSize;				int count = len;		int off2 = off;				while (count > 0) {			if (lastBO.block == null || lastBO.block.uLen >= maxBlockSize) {				appendBlock();			}			/*			System.out.println("Will write at pos " + pos);			System.out.println("len " + len);			System.out.println("newBO.block.cPos " + newBO.block.cPos);			System.out.println("newBO.uOff " + newBO.uOff);			System.out.println("lastBO.uOff " + lastBO.uOff);			System.out.println("lastBO.block.uLen " + lastBO.block.uLen);			*/					 	bytesAllowed = maxBlockSize - lastBO.block.uLen;			chunkSize = count > bytesAllowed ? bytesAllowed : count;						getBlockOutputStream().write(b, off2, chunkSize);						off2 += chunkSize;			pos += chunkSize;			count -= chunkSize;		}			}		public void write(int b) throws IOException {		byte[] buf = new byte[1];		buf[0] = (byte)(b & 0xff);		write(buf, 0, 1);	}	    public int available() throws IOException {    	return (int) (size - pos);    }	public synchronized long getSize() throws IOException {		return size;	}	public void setSize(long newSize) throws IOException {		throw new CannotSetSizeException();	}    public boolean canRead() {    	return vs.canRead();    }    public boolean canWrite() {    	return vs.canWrite();    }    public boolean canSeekFromEnd() {    	return true;    }    public boolean canSeekBackwards() {    	return true;    }    public boolean canSeekForward() {    	return true;    }    public boolean markSupported() {		return true;    }	public void close() throws IOException {		if (!lastBO.block.flushed) {			flushLastBlock(true);		}				if ( !RAZ_H.trailerPresent )			RAZ_H.writeTrailer();		/*		if (iis != null) {			iis.close();			iis = null;		}		*/				if (vs != null) {			vs.close();			vs = null;		}	}						class BlockAndUOff {		public int uOff;		public BlockInfo block;				public BlockAndUOff(BlockInfo block, int uOff) {			this.block = block;			this.uOff = uOff;		}		}	}class BlockInfo {	public int cLen, uLen;	public long cPos, uPos;	boolean flushed = true;	int CRC = 0;	boolean isLastBlockInFork = false;		public BlockInfo(int cLen, int uLen, long cPos, long uPos, int CRC, boolean ILBIF) {		this.cLen = cLen;		this.uLen = uLen;		this.cPos = cPos;		this.uPos = uPos;		this.CRC = CRC;		this.isLastBlockInFork = ILBIF;				}		}