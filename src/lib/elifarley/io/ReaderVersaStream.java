/* ReaderVersaStream -- Returns a VersaStream from a Reader. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.io;import java.io.IOException;import java.io.Reader;public class ReaderVersaStream extends VersaStream {		private Reader in;	private long pos = 0;		public ReaderVersaStream(Reader in) throws IOException {		this.in = in;	}		public int read() throws IOException {		int n = in.read();		if (n != -1) pos++;		return n;	}		    public int read(byte b[], int off, int len) throws IOException {		char cbuff[] = new char[len];		len = in.read(cbuff, off, len);		if (len != -1) pos += len;		new String(cbuff).getBytes(0, len, b, 0);		return len;	}		public void write(int b) throws IOException {		throw new IOException("Writing not allowed");	}	public long seek(long offset, short origin) throws IOException {		long newPos;				switch(origin){			case FROM_BEGINNING: newPos = offset; break;			case FROM_CURRENT: newPos = pos + offset; break;			case FROM_END: newPos = pos + offset; break; // Should we throw an exception here?			default: throw new IOException("Invalid origin: " + origin);		}				if (newPos > pos) {			pos += in.skip(newPos - pos);		}		else			if (newPos < pos) {				in.reset();				pos = in.skip(newPos);			}				if (pos != newPos) throw new IOException("Tried to seek to " + newPos + " but could seek only to " + pos);				return pos;	}		public void setSize(long newSize) throws IOException {		//raf.setSize(newSize);		throw new IOException("Can't set size on a Reader");	}    public boolean canRead() {    	return true;    }    public boolean canWrite() {    	return false;    }    public boolean canSeekFromEnd() {    	return false;    }    public boolean canSeekBackwards() {    	return in.markSupported(); // ?    }    public boolean canSeekForward() {    	return true;    }    public boolean canSetSize() {    	return false;    }    public boolean markSupported() {		return in.markSupported();    }	public synchronized void mark(int readLimit) {		try {			in.mark(readLimit);			} catch (IOException ioe) {		}			}    public synchronized void reset() throws IOException {		in.reset();	}	public void close() throws IOException {		in.close();	}		}