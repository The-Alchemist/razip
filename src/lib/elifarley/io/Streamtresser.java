/* Streamtresser -- Tests the performance of a VersaStream. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */  package elifarley.io;import java.io.IOException;import java.util.Random;public class Streamtresser {	protected VersaStream vs;	protected int maxIter = 5000;	protected int maxBlockSize = 16 * 1024;	protected Random rnd = new Random(1L);		public Streamtresser() {	}	public Streamtresser(VersaStream vs) {		this();		setStream(vs);	}		public void setStream(VersaStream vs) {		this.vs = vs;	}	public void setMaxIter(int maxIter) {		this.maxIter = maxIter;	}		public void setMaxBlockSize(int maxBlockSize) {		this.maxBlockSize = maxBlockSize;	}	public float stress() {		float result = 0;		result = .5f * ( sequentialStress() + randomStress() );		return result;	}		public float sequentialStress() {		System.out.println("Sequential stress");		int bs = maxBlockSize;		int pass = 0;		float result = 0;		float tempR;				try {			vs.setPosition(0);		} catch(IOException ioe) {		}				rnd.setSeed(123456L);				while (bs > 0 && pass < 10) {			//rnd.setSeed(123456L);						tempR = sequentialStress(bs, 0);			result += tempR;			pass++;			System.out.println("size: " + (bs + 1) + "; rate: " + (tempR / 1024f / 1024f) );		}				return result / pass;			}		public float sequentialStress(int blockSize, int skipSize) {						long iTime, fTime;		byte block[] = new byte[blockSize];				int i = 0;				int bytes = 0;		int len;		try {			if (skipSize > 0) {				long pos = 0;								iTime = System.currentTimeMillis();										while (i++ < maxIter) {					vs.setPosition(pos += skipSize);					//skipSize = 400000 +1024 * (int) ( 512f * 2f * rnd.nextFloat() );					if ( (len = vs.read(block, 0, blockSize)) != -1) {						bytes += len;						pos += len;					} else {						pos = 0;						vs.setPosition(0);											}									}			} else {				iTime = System.currentTimeMillis();										while (i++ < maxIter) {					if ( (len = vs.read(block, 0, blockSize)) != -1) {						bytes += len;					} else {						vs.setPosition(0);					}									}			}								} catch (IOException ioe) {			ioe.printStackTrace();			return 0;		}		fTime = System.currentTimeMillis();		System.out.println("bytes read: " + bytes);		return bytes * 1000f / (fTime - iTime);			}	public float randomStress() {		System.out.println("Random stress");		int bs = maxBlockSize;		int pass = 0;		float result = 0;		float tempR;				rnd.setSeed(123456L);				while (bs > 0) {			tempR = randomStress(bs--);			result += tempR;			pass++;			System.out.println("size: " + (bs + 1) + "; rate: " + (tempR / 1024f));		}				return result / pass;			}	public float randomStress(int blockSize) {		long iTime, fTime;		byte block[] = new byte[blockSize];				int i = 0;				int bytes = 0;		int len;		try {			long pos = 0;			long size = vs.getSize();						iTime = System.currentTimeMillis();								while (i++ < maxIter) {				pos = (long) (size * rnd.nextFloat());				//System.out.println("pos: " + pos);				if ( (len = vs.read(pos, block, 0, blockSize)) != -1) {					bytes += len;					//pos += len;				}							}								} catch (IOException ioe) {			ioe.printStackTrace();			return 0;		}		fTime = System.currentTimeMillis();		System.out.println("bytes read: " + bytes);		return bytes * 1000f / (fTime - iTime);	}				}