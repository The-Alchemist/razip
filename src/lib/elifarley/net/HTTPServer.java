/*CopyrightPortions of this software are Copyright (c) 1993 - 2001, Chad Z. Hower (Kudzu) and the Indy Pit Crew - http://www.nevrona.com/Indy/LicenseRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:*	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. *	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation, about box and/or other materials provided with the distribution. *	No personal names or organizations names associated with the Indy project may be used to endorse or promote products derived from this software without specific prior written permission of the specific individual or organization. THIS SOFTWARE IS PROVIDED BY Chad Z. Hower (Kudzu) and the Indy Pit Crew "AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Translation to java and modifications by Elifarley C. Coelho*/package elifarley.net;import elifarley.io.*;import elifarley.util.VersaThread;public class HTTPServer extends TCPServer {		private String serverSoftware;    private boolean parseParams;    public HTTPEventListener onCommand;    //private HTTPOtherEvent onCommandOther;    //private HTTPSessionList sessionList;    private boolean sessionState;    private int sessionTimeOut;    //private OnSessionEndEvent onSessionEnd;    //private OnSessionStartEvent onSessionStart;ÊÊ    private boolean autoStartSession;    //private MIMETable serverMIMETable;    transient private VersaThread sessionCleanupThread;    	public HTTPServer(Object aOwner) {		super(aOwner);  		port = 80; //IdPORT_HTTP;  		parseParams = true;  		//sessionList := TIdHTTPSessionList.Create;  		// MIMETable = new MimeTable(true);	}		public boolean doExecute(PeerThread aThread) {		VersaStream invs;		VersaStream outvs;						HTTPRequestInfo requestInfo = null;		HTTPResponseInfo responseInfo = null;		HTTPEvent ev;				//System.out.println("doExecute called");				try {			invs = VersaStreamFactory.getVersaStream(aThread.getConnection().invs);			outvs = VersaStreamFactory.getVersaStream(aThread.getConnection().outvs);			requestInfo = new HTTPRequestInfo(/*socket.getInetAddress().toString()*/ "192.168.115.7", invs);			responseInfo = new HTTPResponseInfo(outvs);			ev = new HTTPEvent(aThread, requestInfo, responseInfo);		} catch (Exception e) {			System.err.println("Error creating event:");			e.printStackTrace();			aThread.getConnection().disconnectSocket();			return false;		}				try {			onCommand.HTTPCommand(ev);		} catch (Exception e) {			System.err.println("Error running onCommand:");			e.printStackTrace();			responseInfo.setResponseNo(500);			responseInfo.setContentText(e.toString());					}		try {			responseInfo.send();		} catch (Exception e) {			System.err.println("Error sending response:");			e.printStackTrace();		}				aThread.getConnection().disconnectSocket();		return true;			}}/*  protected    procedure SetAutoStartSession(const Value: boolean);    procedure SetOnSessionEnd(const Value: TOnSessionEndEvent);    procedure SetOnSessionStart(const Value: TOnSessionStartEvent);    procedure SetSessionTimeOut(const Value: Integer);    procedure SetActive(AValue: Boolean); override;    procedure SetSessionState(const Value: Boolean);    procedure CaptureHeader(AThread: TIdPeerThread; rsiDest: TIdHTTPRequestInfo); virtual;    function GetSessionFromCookie(HTTPrequest: TIdHTTPRequestInfo; HTTPResponse: TIdHTTPResponseInfo): TIdHTTPSession;  public    property MIMETable: TIdMimeTable read FMIMETable;    function CreateSession(HTTPResponse: TIdHTTPResponseInfo; HTTPRequest: TIdHTTPRequestInfo): TIdHTTPSession;    constructor Create(AOwner: TComponent); override;    destructor Destroy; override;    function DoExecute(AThread: TIdPeerThread): boolean; override;    function ServeFile(AThread: TIdPeerThread; ResponseInfo: TIdHTTPResponseInfo; aFile: TFileName): cardinal; virtual;  published    property OnCommandGet: TIdHTTPGetEvent read FOnCommandGet write FOnCommandGet;    property OnCommandOther: TIdHTTPOtherEvent read FOnCommandOther write FOnCommandOther;    property ParseParams: boolean read FParseParams write FParseParams default True;    property ServerSoftware: string read FServerSoftware write FServerSoftware;    property SessionState: Boolean read FSessionState write SetSessionState;    property AutoStartSession: boolean read FAutoStartSession write SetAutoStartSession;    property SessionTimeOut: Integer read FSessionTimeOut write SetSessionTimeOut;    property OnSessionStart: TOnSessionStartEvent read FOnSessionStart write SetOnSessionStart;    property OnSessionEnd: TOnSessionEndEvent read FOnSessionEnd write SetOnSessionEnd;{ TIdHTTPServer }function TIdHTTPServer.ServeFile(AThread: TIdPeerThread; ResponseInfo: TIdHTTPResponseInfo; AFile: TFileName): Cardinal;begin  ResponseInfo.ContentType := MIMETable.GetFileMIMEType(aFile);  ResponseInfo.ContentLength := FileSizeByName(aFile);  ResponseInfo.WriteHeader;  //TODO allow TransferFileEnabled function  result := aThread.Connection.WriteFile(aFile);end;function TIdHTTPServer.DoExecute(AThread: TIdPeerThread): boolean;var  i: integer;  s, sInputLine, sCmd, sVersion,  sCurrentHeader, sProtocol, sHost, sPort, sPath, sDocument: String;  slBuffer: TStringStream;  RequestInfo: TIdHTTPRequestInfo;  ResponseInfo: TIdHTTPResponseInfo;begin  result := true;  try    slBuffer := TStringStream.Create('');    try      with AThread.Connection do begin        sInputLine := ReadLn;        i := idGlobal.Rpos(' ', sInputLine, -1);        if i = 0 then begin          raise Exception.Create(RSHTTPErrorParsingCommand);        end;        sVersion := Copy(sInputLine, i + 1, MaxInt);        SetLength(sInputLine, i - 1);        {TODO Check for 1.0 only at this point}        sCmd := UpperCase(Fetch(sInputLine, ' '));        // These essentially all "retrieve" so they are all "Get"s        if ((sCmd = 'GET') or (sCmd = 'POST') or (sCmd = 'HEAD')) and assigned(OnCommandGet)         then begin          RequestInfo := TIdHTTPRequestInfo.Create;          try            RequestInfo.FRemoteIP := AThread.Connection.Binding.PeerIP;            RequestInfo.FCommand := sCmd;            CaptureHeader(AThread, RequestInfo);            // Grab Params so we can parse them            if sCmd = 'POST' then            begin              {TODO Change this, not all Posters send content-length}              AThread.Connection.ReadStream(slBuffer, StrToInt(RequestInfo.Headers.Values['Content-Length']));              s := slBuffer.DataString;            end            else            begin              s := sInputLine;              sInputLine := Fetch(s, '?');            end;            RequestInfo.FUnparsedParams := s;            // Parse Params            if ParseParams then begin              // Convert special characters              s := StringReplace(s, '%0D', #27, [rfReplaceAll, rfIgnoreCase]);              s := StringReplace(s, '%0A', '', [rfReplaceAll, rfIgnoreCase]);              s := URLDecode(s);              s := StringReplace(s, '&', EOL, [rfReplaceAll]);              RequestInfo.Params.Text := s;            end;            //Decode Headers            for i := 0 to RequestInfo.Headers.Count - 1 do begin              sCurrentHeader := RequestInfo.Headers[i];              // Cookies              if AnsiPos('cookie=', LowerCase(sCurrentHeader)) > 0 then begin                Delete(sCurrentHeader, 1, Ansipos('=', sCurrentHeader));                sCurrentHeader := StringReplace(sCurrentHeader, ': ', '=', [rfReplaceAll]);                While AnsiPos(';', sCurrentHeader) > 0 do begin                  RequestInfo.Cookies.AddSrcCookie(Copy(sCurrentHeader, 1, AnsiPos(';', sCurrentHeader) - 1));                  Delete(sCurrentHeader, 1, AnsiPos(';', sCurrentHeader));                end;                RequestInfo.Cookies.AddSrcCookie(sCurrentHeader);              end;              // Host              if Ansipos('host=', LowerCase(sCurrentHeader)) > 0  then              begin                Delete(sCurrentHeader, 1, Ansipos('=', sCurrentHeader));                RequestInfo.FHost := sCurrentHeader;              end;            end;            RequestInfo.FVersion := sVersion;            // Parse the document input line            if sInputLine = '*' then            begin              RequestInfo.FDocument := '*';            end            else            begin              ParseURI(sInputLine, sProtocol, sHost, sPath, sDocument, sPort);              RequestInfo.FDocument := sPath + sDocument;            end;            // Try to fill the "host" parameter            if (Length(sHost) > 0) and (Length            (RequestInfo.FHost) = 0) then               RequestInfo.FHost := sHost;            s := RequestInfo.Headers.Values['Authorization'];            RequestInfo.AuthExists := Length(s) > 0;            if RequestInfo.AuthExists then begin              if AnsiCompareText(Fetch(s, ' '), 'Basic') = 0 then begin                s := Base64Decode(s);                RequestInfo.AuthUsername := Fetch(s, ':');                RequestInfo.AuthPassword := s;              end else begin                raise Exception.Create(RSHTTPUnsupportedAuthorisationScheme);              end;            end;            //            ResponseInfo := TIdHTTPResponseInfo.Create(AThread.Connection);            try              // Session management              GetSessionFromCookie(RequestInfo, ResponseInfo);              // SG 05.07.99              // Set the ServerSoftware string to what it's supposed to be.              if Length(Trim(ServerSoftware)) > 0  then                 ResponseInfo.FServerSoftware := ServerSoftware;              try                 OnCommandGet(AThread, RequestInfo, ResponseInfo);              except                on E: Exception do begin                  ResponseInfo.ResponseNo := 500;                  ResponseInfo.ContentText := E.Message;                end;              end;              if not ResponseInfo.HeaderHasBeenWritten then begin                // Auto Populate Header values where possible                // DO NOT try this in WriteHeader - WriteHeader may be called by user for an unknown                // content                // Always check ContentText first                with ResponseInfo do begin                  if Length(ContentText) > 0 then begin                    ContentLength := Length(ContentText)                  end else if Assigned(ContentStream) then begin                    ContentLength := ContentStream.Size;                  end;                  WriteHeader;                end;              end;              // Always check ContentText first              if Length(ResponseInfo.ContentText) > 0 then begin                ResponseInfo.WriteContent;              end else if Assigned(ResponseInfo.ContentStream) then begin                ResponseInfo.ContentStream.Position := 0;                ResponseInfo.WriteContent;              end;            finally ResponseInfo.Free; end;          finally RequestInfo.Free; end;        end else begin          if assigned(OnCommandOther) then            OnCommandOther(AThread, sCmd, sInputLine, sVersion);        end;      end;    finally      slBuffer.Free;    end;  finally  	AThread.Connection.Disconnect;  end;end;destructor TIdHTTPServer.Destroy;begin  FreeAndNil(FMIMETable);  FreeAndNil(FSessionList);  inherited;end;function TIdHTTPServer.CreateSession(HTTPResponse: TIdHTTPResponseInfo; HTTPRequest: TIdHTTPRequestInfo): TIdHTTPSession;var  SessionID: string;begin  if SessionState then begin    SessionID := getRandomString(15);    result := FSessionList.CreateSession(HTTPrequest.RemoteIP, SessionID);    HTTPResponse.Cookies.Append('IDHTTPSESSIONID=' + SessionID);    HTTPResponse.FSession := result;    HTTPRequest.FSession := result;  end else begin    result := nil;  end;end;function TIdHTTPServer.GetSessionFromCookie(HTTPRequest: TIdHTTPRequestInfo; HTTPResponse: TIdHTTPResponseInfo): TIdHTTPSession;var  CurrentCookieIndex: Integer;begin  result := nil;  if SessionState then  begin    CurrentCookieIndex := HTTPRequest.Cookies.GetCookieIndex(0, 'IDHTTPSESSIONID');    while (result = nil) and (CurrentCookieIndex >= 0) do    begin      result := FSessionList.GetSession(HTTPRequest.Cookies.Items[CurrentCookieIndex].Value, HTTPrequest.RemoteIP);      // Update the session's timestamp      if assigned( result ) then        Result.FLastTimeStamp := DateTimeToTimeStamp(now);      Inc(CurrentCookieIndex);      CurrentCookieIndex := HTTPRequest.Cookies.GetCookieIndex(CurrentCookieIndex, 'IDHTTPSESSIONID');    end;    { while }    // check if a session was returned. If not and if AutoStartSession is set to    // true, Create a new session    if FAutoStartSession and (result = nil) then    begin      result := CreateSession(HTTPResponse, HTTPrequest);    end;  end;  HTTPRequest.FSession := result;  HTTPResponse.FSession := result;end;procedure TIdHTTPServer.SetSessionState(const Value: Boolean);begin  // ToDo: Add thread multiwrite protection here  if (not (csDesigning in ComponentState)) and Active then    raise exception.create(RSHTTPCannotSwitchSessionStateWhenActive);  FSessionState := Value;end;procedure TIdHTTPServer.SetSessionTimeOut(const Value: Integer);begin  FSessionTimeOut := Value;end;procedure TIdHTTPServer.SetOnSessionEnd(const Value: TOnSessionEndEvent);begin  FOnSessionEnd := Value;end;procedure TIdHTTPServer.SetOnSessionStart(  const Value: TOnSessionStartEvent);begin  FOnSessionStart := Value;end;procedure TIdHTTPServer.SetAutoStartSession(const Value: boolean);begin  FAutoStartSession := Value;end;*/