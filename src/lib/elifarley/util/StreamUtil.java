/* StreamUtil -- Utility functions to work with VersaStreams. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.util;import elifarley.io.*;import java.io.Reader;import java.io.Writer;import java.io.DataInput;import java.io.DataInputStream;import java.io.DataOutput;import java.io.InputStream;import java.io.OutputStream;import java.io.EOFException;import java.io.IOException;public class StreamUtil {	public static final int MAXBUFSIZE = 65536;    public static long copy(VersaStream source, VersaStream dest, long count) throws IOException {		   		/*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from beginning up to the end. Source may be asked to seek backwards   		*/   		  		  		long result = 0;  		byte buffer[];  		     	if (source instanceof MemoryVersaStream) {  			synchronized(source) {				MemoryVersaStream mvs = (MemoryVersaStream)source;				if (count == 0) count = source.getSize() - source.getPosition();				byte buf[] = mvs.getBuffer();				synchronized ( dest ) {	    			dest.write( buf, (int)source.getPosition(), (int)count ); 				}			}	    	return count;    	}  		synchronized(source) {	  		synchronized(dest) {		  		if (count < 0) {		  			if ( source.getPosition() != 0) source.setPosition(0);		  			count = 0;		  		}		  							 		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		buffer = new byte[bufSize];		  				  		int i;		  		if (count==0) // We need to copy the whole source		  			while ((i = source.read(buffer, 0, bufSize)) != -1) {						dest.write(buffer, 0, i);						result += i;			    	}			    else // We need to copy up to count bytes		  			while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {						dest.write(buffer, 0, i);						result += i;						count -= i;			    	}			}					      		  		}  		buffer = null;  		return result;  		  		  	}    public static long copy(DataInput source, VersaStream dest, long count) throws IOException {		  		   		/*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from last marked position up to the end. Source will be asked to reset   		*/	   	  		long result = 0;  		byte buffer[];  		     	if (source instanceof MemoryVersaStream) {  			synchronized(source) {				MemoryVersaStream mvs = (MemoryVersaStream)source;				if (count == 0) count = mvs.getSize() - mvs.getPosition();				byte buf[] = mvs.getBuffer();				synchronized ( dest ) {	    			dest.write( buf, (int)mvs.getPosition(), (int)count ); 				}			}	    	return count;    	}  		synchronized(source) {  			synchronized(dest) {		  		if (count < 0 && !(source instanceof VersaStream) ) {		  			throw new IOException("Copying from beginning not supported with DataInput");  					  		} else {		  				  		}		  		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		buffer = new byte[bufSize];		  				  		int i;		  		if (count==0) 		  			while ((i = source.readByte()) != -1) {						dest.write(i);						result ++;			    	}			    else		  			while (count > 0 && (i = source.readByte()) != -1) {						dest.write(i);						result ++;						count --;			    	}			}				  			 	}  		buffer = null;  		return result;  	}    public static long copy(InputStream source, VersaStream dest, long count) throws IOException {		  		   		/*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from last marked position up to the end. Source will be asked to reset   		*/   		long result = 0;		byte buffer[];  		synchronized(source) {	  		synchronized(dest) {		  		if (count < 0) {		  			//throw new IOException("Copying from beginning not supported with InputStreams");		  			source.reset();		  			count = 0;		  		}		  		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		buffer = new byte[bufSize];		  				  		int i;	  				  		if (count==0) 		  			while ((i = source.read(buffer, 0, bufSize)) != -1) {						dest.write(buffer, 0, i);						result += i;			    	}			    else		  			while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {						dest.write(buffer, 0, i);						result += i;						count -= i;			    	}			}					}		  		  		buffer = null;  		return result;  	}    public static long copy(Reader source, VersaStream dest, long count) throws IOException {		  		   		/*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from last marked position up to the end. Source will be asked to reset   		*/   		long result = 0;		char buffer[];  		synchronized(source) {	  		synchronized(dest) {		  		if (count < 0) {		  			//throw new IOException("Copying from beginning not supported with InputStreams");		  			source.reset();		  			count = 0;		  		}		  		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		 buffer = new char[bufSize];		  				  		int i;		  		if (count==0) 		  			while ((i = source.read(buffer, 0, bufSize)) != -1) {						dest.writeChars(new String(buffer).substring(0, i));						result += i;			    	}			    else		  			while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {						dest.writeChars(new String(buffer).substring(0, i));						result += i;						count -= i;			    	}			}							}  		  		  		buffer = null;  		return result;  	}    public static long copy(VersaStream source, DataOutput dest, long count) throws IOException {		  		   		long result = 0;		byte buffer[];  		synchronized(source) {	  		synchronized(dest) {		  		if (count < 0) {		  			if (source.getPosition() != 0) source.setPosition(0);		  			count = 0;		  		}		  		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		buffer = new byte[bufSize];		  				  		int i;		  				  		if (count==0) 		  			while ((i = source.read(buffer, 0, bufSize)) != -1) {						dest.write(buffer, 0, i);						result += i;			    	}			    else		  			while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {						dest.write(buffer, 0, i);						result += i;						count -= i;			    	}  			}  		}  		  		buffer = null;  		return result;  	}    public static long copy(VersaStream source, OutputStream dest, long count) throws IOException {		  		   		long result = 0;		byte buffer[];  		synchronized(source) {	  		synchronized(dest) {		  		if (count < 0) {		  			if (source.getPosition() != 0) source.setPosition(0);		  			count = 0;		  		}		  		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		buffer = new byte[bufSize];		  				  		int i;		  				  		if (count==0) 		  			while ((i = source.read(buffer, 0, bufSize)) != -1) {						dest.write(buffer, 0, i);						result += i;			    	}			    else		  			while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {						dest.write(buffer, 0, i);						result += i;						count -= i;			    	}			}		}  		  		  		buffer = null;  		return result;  	}    public static long copy(VersaStream source, Writer dest, long count) throws IOException {		  		  		//return copyTo(new OutputStreamWriter(dest), count);  		   		long result = 0;		byte buffer[];		  		synchronized(source) {	  		synchronized(dest) {		  		if (count < 0) {		  			if (source.getPosition() != 0) source.setPosition(0);		  			count = 0;		  		}		  		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;		  		buffer = new byte[bufSize];		  				  		int i;		  				  		if (count==0) 		  			while ((i = source.read(buffer, 0, bufSize)) != -1) {						dest.write(new String(buffer).substring(0, i) );						result += i;			    	}			    else		  			while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {						dest.write(new String(buffer).substring(0, i) );						result += i;						count -= i;			    	}			}					}  		  		buffer = null;  		return result;		  		  	}    /*    public synchronized long copyTo(String dest, long count) throws IOException {		// it will not work !!!!!!!  		if (count < 0) {  			if (this.getPosition() != 0) this.setPosition(0);  			count = 0;  		}		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;  		byte buffer[] = new byte[bufSize];  		  		int i;   		long result = 0;  		StringBuffer sb = new StringBuffer();  		  		if (count==0)   			while ((i = this.read(buffer, 0, bufSize)) != -1) {				sb.append(new String(buffer, 0, i));				result += i;	    	}	    else  			while (count > 0 && (i = this.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {				sb.append(new String(buffer, 0, i));				result += i;				count -= i;	    	}	  		  		buffer = null;  		// it does not work !!!!!  		dest = sb.toString();  		// !!!!!!!!!!!!!!!!!!!!!!  		sb = null;  		return result;					}	    public synchronized final long copyTo(String dest) throws IOException {		return copyTo(dest, -1);	}	*/} 