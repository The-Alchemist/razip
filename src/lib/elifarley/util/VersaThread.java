/*CopyrightPortions of this software are Copyright (c) 1993 - 2001, Chad Z. Hower (Kudzu) and the Indy Pit Crew - http://www.nevrona.com/Indy/LicenseRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:*	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. *	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation, about box and/or other materials provided with the distribution. *	No personal names or organizations names associated with the Indy project may be used to endorse or promote products derived from this software without specific prior written permission of the specific individual or organization. THIS SOFTWARE IS PROVIDED BY Chad Z. Hower (Kudzu) and the Indy Pit Crew "AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Translation to java and modifications by Elifarley C. Coelho*/package elifarley.util;public abstract class VersaThread extends Thread {  	public static final int SM_TERMINATE = 0;  	public static final int SM_SUSPEND = 1;	    //private Handle handle;    //private threadID: THandle;    public boolean terminated = false;    private boolean suspended = true;    private boolean freeOnTerminate;    private boolean finished;    private int returnValue;    // public NotifyEvent onTerminate;    //private ThreadMethod method;    private Object synchronizeException;	public Object data;    public int stopMode; //: TIdThreadStopMode;    protected boolean stopped = true;    protected String terminatingException;    // public onException: TIdExceptionEvent;	//public    //property threadID: THandle read FThreadID;        //protected void synchronize(Method: TThreadMethod);      public VersaThread(boolean createSuspended) {		super();		//Flags: DWORD;  		//AddThread;  		//suspended = createSuspended;  		//flags = 0;  		//if CreateSuspended then Flags = CREATE_SUSPENDED;  		//FHandle = BeginThread(nil, 0, @ThreadProc, Pointer(Self), Flags, FThreadID);    	if (!createSuspended) v_start();    }         public VersaThread() {    	this(true);    }            protected abstract void execute();	public void afterRun() {}	public void beforeRun() {}    private void callOnTerminate() {    }        protected void doTerminate() {    }      	public String getTerminatingException() {  		return new String(terminatingException);  	}    protected int getReturnValue() {    	return returnValue;    }        protected void setReturnValue(int value) {    	returnValue = value;    }        void v_suspend() {		if (suspended) return;		suspended = true;		//SuspendThread(FHandle);		suspend();    }        void v_resume() {  		if (suspended) { //resumeThread(FHandle) = 1   			if ( isAlive() ) {  				//System.out.println("Will resume");  				resume();  			}  			else {  				//System.out.println("Will start");  				start();  			}  			  			suspended = false;  		}    } 	public boolean getSuspended() { 		return suspended; 	} 	 	public void setSuspended(boolean value) {  		//if (value != suspended) {    		    		if (value) {      			v_suspend();       		} else {      			v_resume();      		}		//}	}	public void terminate() {  		terminated = true;	}    	public boolean getStopped() {		return terminated || stopped;	}    public void v_stop() {		if ( ! getStopped() )  {			switch(stopMode) {				case SM_TERMINATE: terminate(); break;				// DO NOT suspend here. Suspend is immediate. See Execute for implementation				case SM_SUSPEND: stopped = true; break;			}		}    }	public void v_start() {		if ( getStopped() ) {    		// Resume is also called for smTerminate as .Start can be used to initially start a    		// thread that is created suspended    		stopped = false;    		terminated = false;    		setSuspended(false);  		}	}    public void waitFor() throws InterruptedException {    	join(0);    }    	public void terminateAndWaitFor() throws InterruptedException {  		terminate();  		stopped = true;  		waitFor();	}	public final void run() {	  	//System.out.println("VersaThread.run entered");	  	try {	    	while (!terminated ) {	    		try {	      			if ( getStopped() )  {	        			setSuspended(true); // thread manager will revive us		        				        		if ( terminated ) {		          			break;		          		}	          		}	      			beforeRun();	      			while (!getStopped()) {	        			execute();	      			}	    		} catch(Exception e) {	    			this.dumpStack();	    			e.printStackTrace();	    		}	    		afterRun();	    	}	  	} catch (Exception e) {	   		terminatingException = e.toString();	      	//if ( Assigned(FOnException) 	       		//FOnException(self, E);	    }	    	    terminate();	    suspended = true;		}	}/*{ TThread }  EThread = class(Exception);  TThreadMethod = void of object;  TThreadPriority = (tpIdle, tpLowest, tpLower, tpNormal, tpHigher, tpHighest,    tpTimeCritical);  TThread = class  }{ TThread }function ThreadProc(Thread: TThread): Integer;var  FreeThread: Boolean;{  try    Thread.Execute;  finally    FreeThread = Thread.FFreeOnTerminate;    Result = Thread.FReturnValue;    Thread.FFinished = True;    Thread.DoTerminate;    if FreeThread then Thread.Free;    EndThread(Result);  }}destructor TThread.Destroy;{  if not FFinished and not Suspended then  {    Terminate;    WaitFor;  }  if FHandle <> 0 then CloseHandle(FHandle);  inherited Destroy;  RemoveThread;}void TThread.CallOnTerminate;{  if (onTerminate != null)  onTerminate.act(this);}void TThread.DoTerminate;{  //if (onTerminate != null) synchronize(CallOnTerminate);}const  Priorities: array [TThreadPriority] of Integer =   (THREAD_PRIORITY_IDLE, THREAD_PRIORITY_LOWEST, THREAD_PRIORITY_BELOW_NORMAL,    THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_ABOVE_NORMAL,    THREAD_PRIORITY_HIGHEST, THREAD_PRIORITY_TIME_CRITICAL);void TThread.Synchronize(Method: TThreadMethod);{  synchronizeException = nil;  FMethod = Method;  sendMessage(ThreadWindow, CM_EXECPROC, 0, Longint(Self));  if (assigned(FSynchronizeException) then raise FSynchronizeException;}type  TIdExceptionEvent = void (Sender: TObject; E: Exception) of object;  TIdThreadClass = class of thread;void synchronize(method: threadMethod);{  inherited synchronize(method);}*/